import { ensureDirSync, writeFileSync, removeSync } from 'fs-extra';
import { tmpdir } from 'node:os';
import { join, resolve } from 'path';
import { loadManifest } from '@/cli/utils/load-manifest';
import { ManifestValidationError } from '../validate-manifest';

const write = (root: string, file: string, content: string) => {
  const abs = join(root, file);
  ensureDirSync(resolve(abs, '..'));
  writeFileSync(abs, content, 'utf8');
};

// Mock type definitions for twenty-sdk
const twentySdkTypesMock = `
declare module 'twenty-sdk' {
  export type SyncableEntityOptions = { universalIdentifier: string };

  export type ApplicationConfig = SyncableEntityOptions & {
    displayName?: string;
    description?: string;
    icon?: string;
  };

  export type FunctionConfig = SyncableEntityOptions & {
    name?: string;
    description?: string;
    timeoutSeconds?: number;
    triggers?: any[];
  };

  export type RoleConfig = SyncableEntityOptions & {
    label: string;
    description?: string;
  };

  export type ObjectManifest = SyncableEntityOptions & {
    nameSingular: string;
    namePlural: string;
    labelSingular: string;
    labelPlural: string;
    fields: any[];
  };

  export enum FieldType {
    TEXT = 'TEXT',
    SELECT = 'SELECT',
  }

  export const defineApp: <T>(config: T) => T;
  export const defineObject: <T>(config: T) => T;
  export const defineFunction: <T>(config: T) => T;
  export const defineRole: <T>(config: T) => T;
}
`;

const packageJsonMock = {
  name: 'my-app',
  version: '0.0.1',
  license: 'MIT',
};

const tsConfigJsonMock = {
  compilerOptions: {
    target: 'es2020',
    module: 'esnext',
    moduleResolution: 'node',
    esModuleInterop: true,
    skipLibCheck: true,
  },
};

const yarnLockMock = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1
`;

// Shared constants file that will be imported by configs
const constantsMock = `
export const APP_ID = 'a9faf5f8-cf7e-4f24-9d37-fd523c30febe';
export const POST_CARD_ID = '54b589ca-eeed-4950-a176-358418b85c05';
export const FIELD_ID = '58a0a314-d7ea-4865-9850-7fb84e72f30b';
export const FUNCTION_ID = 'e56d363b-0bdc-4d8a-a393-6f0d1c75bdcf';
export const TRIGGER_ID = 'c9f84c8d-b26d-40d1-95dd-4f834ae5a2c6';
export const ROLE_ID = 'b648f87b-1d26-4961-b974-0908fd991061';
`;

// Handler file that will be imported by function config
const handlerMock = `
export const sendPostcardHandler = async (params: any) => {
  return { success: true };
};
`;

// App config that imports from constants
const appConfigMock = `
import { APP_ID } from '../src/constants';

export default {
  universalIdentifier: APP_ID,
  displayName: 'My App',
  description: 'My app description',
  icon: 'IconWorld',
};
`;

// Object config that imports from constants
const objectConfigMock = `
import { POST_CARD_ID, FIELD_ID } from '../../src/constants';

export default {
  universalIdentifier: POST_CARD_ID,
  nameSingular: 'postCard',
  namePlural: 'postCards',
  labelSingular: 'Post Card',
  labelPlural: 'Post Cards',
  icon: 'IconMail',
  fields: [
    {
      universalIdentifier: FIELD_ID,
      type: 'TEXT',
      label: 'Content',
    },
  ],
};
`;

// Function config that imports handler from another file
const functionConfigMock = `
import { FUNCTION_ID, TRIGGER_ID } from '../../src/constants';
import { sendPostcardHandler } from '../../src/handlers/send-postcard';

export const config = {
  universalIdentifier: FUNCTION_ID,
  name: 'Send Postcard',
  timeoutSeconds: 30,
  handler: sendPostcardHandler,
  triggers: [
    {
      universalIdentifier: TRIGGER_ID,
      type: 'route',
      path: '/postcards/send',
      httpMethod: 'POST',
      isAuthRequired: true,
    },
  ],
};
`;

// Role config that imports from constants
const roleConfigMock = `
import { ROLE_ID } from '../../src/constants';

export default {
  universalIdentifier: ROLE_ID,
  label: 'App User',
  description: 'Standard user role',
};
`;

describe('loadManifestV2 (integration)', () => {
  const appDirectory = join(tmpdir(), 'test-app-v2-' + Date.now());

  beforeEach(async () => {
    ensureDirSync(appDirectory);

    // Create folder structure
    write(appDirectory, 'yarn.lock', yarnLockMock);
    write(
      appDirectory,
      'package.json',
      JSON.stringify(packageJsonMock, null, 2),
    );
    write(
      appDirectory,
      'tsconfig.json',
      JSON.stringify(tsConfigJsonMock, null, 2),
    );

    // Type definitions
    write(appDirectory, 'src/types/twenty-sdk.d.ts', twentySdkTypesMock);

    // Shared constants
    write(appDirectory, 'src/constants.ts', constantsMock);

    // Handler file
    write(appDirectory, 'src/handlers/send-postcard.ts', handlerMock);

    // App config
    write(appDirectory, 'app/application.config.ts', appConfigMock);

    // Object
    write(appDirectory, 'app/objects/post-card.object.ts', objectConfigMock);

    // Function
    write(
      appDirectory,
      'app/functions/send-postcard.function.ts',
      functionConfigMock,
    );

    // Role
    write(appDirectory, 'app/roles/app-user.role.ts', roleConfigMock);
  });

  afterEach(() => {
    removeSync(appDirectory);
  });

  it('should load manifest with imported constants resolved', async () => {
    const { manifest, packageJson } = await loadManifest(appDirectory);

    // Check package.json loaded
    expect(packageJson.name).toBe('my-app');

    // Check application config - constants should be resolved!
    expect(manifest.application.universalIdentifier).toBe(
      'a9faf5f8-cf7e-4f24-9d37-fd523c30febe',
    );
    expect(manifest.application.displayName).toBe('My App');

    // Check object - constants should be resolved!
    expect(manifest.objects).toHaveLength(1);
    expect(manifest.objects[0].universalIdentifier).toBe(
      '54b589ca-eeed-4950-a176-358418b85c05',
    );
    expect(manifest.objects[0].nameSingular).toBe('postCard');
    expect(manifest.objects[0].fields).toHaveLength(1);
    expect(manifest.objects[0].fields![0].universalIdentifier).toBe(
      '58a0a314-d7ea-4865-9850-7fb84e72f30b',
    );

    // Check function - constants should be resolved!
    expect(manifest.serverlessFunctions).toHaveLength(1);
    expect(manifest.serverlessFunctions[0].universalIdentifier).toBe(
      'e56d363b-0bdc-4d8a-a393-6f0d1c75bdcf',
    );
    expect(manifest.serverlessFunctions[0].name).toBe('Send Postcard');
    expect(manifest.serverlessFunctions[0].handlerName).toBe(
      'sendPostcardHandler',
    );
    expect(manifest.serverlessFunctions[0].handlerPath).toBe(
      'src/handlers/send-postcard.ts',
    );
    expect(manifest.serverlessFunctions[0].triggers).toHaveLength(1);
    expect(
      manifest.serverlessFunctions[0].triggers[0].universalIdentifier,
    ).toBe('c9f84c8d-b26d-40d1-95dd-4f834ae5a2c6');

    // Check role - constants should be resolved!
    expect(manifest.roles).toHaveLength(1);
    expect(manifest.roles?.[0].universalIdentifier).toBe(
      'b648f87b-1d26-4961-b974-0908fd991061',
    );
    expect(manifest.roles?.[0].label).toBe('App User');

    // Check sources loaded
    expect(manifest.sources).toBeDefined();
    expect(manifest.sources['app']).toBeDefined();
    expect(manifest.sources['src']).toBeDefined();
  });

  it('should support nested object folders', async () => {
    // Add a nested object
    const nestedObjectConfig = `
export default {
  universalIdentifier: 'nested-obj-id-1234',
  nameSingular: 'contact',
  namePlural: 'contacts',
  labelSingular: 'Contact',
  labelPlural: 'Contacts',
  fields: [
    {
      universalIdentifier: 'nested-field-id-1234',
      type: 'TEXT',
      label: 'Name',
    },
  ],
};
`;
    write(
      appDirectory,
      'app/objects/crm/contact.object.ts',
      nestedObjectConfig,
    );

    const { manifest } = await loadManifest(appDirectory);

    expect(manifest.objects).toHaveLength(2);
    const contact = manifest.objects.find((o) => o.nameSingular === 'contact');
    expect(contact).toBeDefined();
    expect(contact?.universalIdentifier).toBe('nested-obj-id-1234');
  });

  it('should support nested function folders', async () => {
    // Create handler file for nested function
    const nestedHandlerMock = `
export const dailyReportHandler = async () => ({ sent: true });
`;
    write(appDirectory, 'src/handlers/daily-report.ts', nestedHandlerMock);

    const nestedFunctionConfig = `
import { dailyReportHandler } from '../../../src/handlers/daily-report';

export const config = {
  universalIdentifier: 'nested-fn-id-1234',
  name: 'Daily Report',
  handler: dailyReportHandler,
  triggers: [
    {
      universalIdentifier: 'nested-trigger-id-1234',
      type: 'cron',
      pattern: '0 9 * * *',
    },
  ],
};
`;
    write(
      appDirectory,
      'app/functions/jobs/daily-report.function.ts',
      nestedFunctionConfig,
    );

    const { manifest } = await loadManifest(appDirectory);

    expect(manifest.serverlessFunctions).toHaveLength(2);
    const dailyReport = manifest.serverlessFunctions.find(
      (f) => f.name === 'Daily Report',
    );
    expect(dailyReport).toBeDefined();
    expect(dailyReport?.handlerName).toBe('dailyReportHandler');
    expect(dailyReport?.handlerPath).toBe('src/handlers/daily-report.ts');
  });

  it('should support handler defined locally in function file', async () => {
    const localHandlerFunctionConfig = `
export const localHandler = async (params: any) => {
  return { processed: true, params };
};

export const config = {
  universalIdentifier: 'local-handler-fn-id',
  name: 'Local Handler Function',
  handler: localHandler,
  triggers: [
    {
      universalIdentifier: 'local-trigger-id',
      type: 'route',
      path: '/local',
      httpMethod: 'GET',
      isAuthRequired: false,
    },
  ],
};
`;
    write(
      appDirectory,
      'app/functions/local-handler.function.ts',
      localHandlerFunctionConfig,
    );

    const { manifest } = await loadManifest(appDirectory);

    const localFn = manifest.serverlessFunctions.find(
      (f) => f.name === 'Local Handler Function',
    );
    expect(localFn).toBeDefined();
    expect(localFn?.handlerName).toBe('localHandler');
    expect(localFn?.handlerPath).toBe(
      'app/functions/local-handler.function.ts',
    );
  });

  it('should support multiple imports', async () => {
    // Create handler file with multiple imports
    const nestedHandlerMock = `
export const dailyReportHandler = async () => ({ sent: true });
`;
    write(appDirectory, 'src/handlers/daily-report.ts', nestedHandlerMock);

    const nestedFunctionConfig = `
import { util1, dailyReportHandler, util2 } from '../../../src/handlers/daily-report';

export const config = {
  universalIdentifier: 'nested-fn-id-1234',
  name: 'Daily Report',
  handler: dailyReportHandler,
  triggers: [
    {
      universalIdentifier: 'nested-trigger-id-1234',
      type: 'cron',
      pattern: '0 9 * * *',
    },
  ],
};
`;
    write(
      appDirectory,
      'app/functions/jobs/daily-report.function.ts',
      nestedFunctionConfig,
    );

    const { manifest } = await loadManifest(appDirectory);

    expect(manifest.serverlessFunctions).toHaveLength(2);
    const dailyReport = manifest.serverlessFunctions.find(
      (f) => f.name === 'Daily Report',
    );
    expect(dailyReport).toBeDefined();
    expect(dailyReport?.handlerName).toBe('dailyReportHandler');
    expect(dailyReport?.handlerPath).toBe('src/handlers/daily-report.ts');
  });

  it('should throw error when app/ folder is missing', async () => {
    const noAppDir = join(tmpdir(), 'test-no-app-' + Date.now());
    ensureDirSync(noAppDir);
    write(noAppDir, 'package.json', JSON.stringify(packageJsonMock, null, 2));
    write(noAppDir, 'yarn.lock', yarnLockMock);

    await expect(loadManifest(noAppDir)).rejects.toThrow('Missing app/ folder');

    removeSync(noAppDir);
  });

  it('should throw error when application.config.ts is missing', async () => {
    const noConfigDir = join(tmpdir(), 'test-no-config-' + Date.now());
    ensureDirSync(noConfigDir);
    ensureDirSync(join(noConfigDir, 'app'));
    write(
      noConfigDir,
      'package.json',
      JSON.stringify(packageJsonMock, null, 2),
    );
    write(noConfigDir, 'yarn.lock', yarnLockMock);

    await expect(loadManifest(noConfigDir)).rejects.toThrow(
      'Missing app/application.config.ts',
    );

    removeSync(noConfigDir);
  });

  it('should throw validation error for duplicate universalIdentifiers', async () => {
    // Create a role with the same ID as the app
    const duplicateRoleConfig = `
export default {
  universalIdentifier: 'a9faf5f8-cf7e-4f24-9d37-fd523c30febe', // Same as app ID
  label: 'Duplicate Role',
};
`;
    write(appDirectory, 'app/roles/duplicate.role.ts', duplicateRoleConfig);

    await expect(loadManifest(appDirectory)).rejects.toThrow(
      ManifestValidationError,
    );

    try {
      await loadManifest(appDirectory);
    } catch (error) {
      expect(error).toBeInstanceOf(ManifestValidationError);
      const validationError = error as ManifestValidationError;
      expect(validationError.errors).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            message: expect.stringContaining('Duplicate universalIdentifier'),
          }),
        ]),
      );
    }
  });

  it('should detect shouldGenerate when imports from generated folder', async () => {
    // Add a file that imports from generated
    const fileWithGenerated = `
import { SomeType } from '../generated';
export const foo = 'bar';
`;
    write(appDirectory, 'src/utils/helper.ts', fileWithGenerated);

    const { shouldGenerate } = await loadManifest(appDirectory);
    expect(shouldGenerate).toBe(true);
  });

  it('should not set shouldGenerate when no generated imports', async () => {
    const { shouldGenerate } = await loadManifest(appDirectory);
    expect(shouldGenerate).toBe(false);
  });
});
