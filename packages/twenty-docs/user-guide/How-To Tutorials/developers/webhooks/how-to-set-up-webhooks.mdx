---
title: How to Set Up Webhooks
info: "Configure webhooks to receive real-time notifications from Twenty."
difficulty: "intermediate"
time: "20 minutes"
---

<Frame>
  <img src="/images/user-guide/webhooks/webhook-setup.png" alt="Webhook Setup" />
</Frame>

Webhooks allow your applications to receive real-time notifications when data changes in your Twenty workspace. Instead of constantly polling the API for updates, webhooks push notifications to your application immediately when events occur.

## Understanding Webhooks

### What Are Webhooks?
Webhooks are HTTP callbacks that Twenty sends to your application when specific events happen in your workspace. Think of them as "reverse API calls" - instead of your application requesting data, Twenty proactively sends data to you.

### Benefits of Webhooks
- **Real-time updates**: Get notified immediately when data changes
- **Reduced API calls**: No need to poll for changes constantly
- **Event-driven architecture**: Build responsive applications that react to CRM events
- **Efficient integration**: Only process data when something actually changes
- **Scalable solutions**: Handle high-volume data changes efficiently

### Common Use Cases
- **Sync data** with external systems in real-time
- **Trigger workflows** in other applications when deals close
- **Send notifications** to team communication tools
- **Update dashboards** with live CRM data
- **Log activities** for audit and compliance purposes

## Webhook Events

### Available Event Types

**Record Events**:
- `record.created`: When a new record is created
- `record.updated`: When an existing record is modified
- `record.deleted`: When a record is deleted

**Object-Specific Events**:
- `person.created`, `person.updated`, `person.deleted`
- `company.created`, `company.updated`, `company.deleted`
- `opportunity.created`, `opportunity.updated`, `opportunity.deleted`
- `task.created`, `task.updated`, `task.deleted`

**Custom Object Events**:
- Events for any custom objects you've created
- Follow the same pattern: `customObject.created`, etc.

### Event Payload Structure

**Standard webhook payload**:
```json
{
  "event": "record.created",
  "objectName": "person",
  "recordId": "12345",
  "workspaceId": "workspace-abc",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "id": "12345",
    "firstName": "John",
    "lastName": "Doe",
    "email": "john.doe@example.com",
    "company": {
      "id": "67890",
      "name": "Acme Corp"
    }
  },
  "previousData": null
}
```

**Update event payload**:
```json
{
  "event": "record.updated",
  "objectName": "opportunity",
  "recordId": "54321",
  "workspaceId": "workspace-abc",
  "timestamp": "2024-01-15T10:35:00Z",
  "data": {
    "id": "54321",
    "name": "Enterprise Deal",
    "amount": 150000,
    "stage": "Closed Won"
  },
  "previousData": {
    "stage": "Negotiation",
    "amount": 120000
  }
}
```

## Setting Up Webhooks

### Step 1: Prepare Your Endpoint

**Create a webhook endpoint** in your application that can receive POST requests:

**Node.js/Express example**:
```javascript
const express = require('express');
const app = express();

app.use(express.json());

app.post('/webhooks/twenty', (req, res) => {
  const { event, objectName, recordId, data } = req.body;

  console.log(`Received ${event} for ${objectName} record ${recordId}`);
  console.log('Data:', data);

  // Process the webhook data here
  processWebhookEvent(event, objectName, data);

  // Always respond with 200 OK
  res.status(200).send('OK');
});

app.listen(3000, () => {
  console.log('Webhook server listening on port 3000');
});
```

**Python/Flask example**:
```python
from flask import Flask, request, jsonify
import json

app = Flask(__name__)

@app.route('/webhooks/twenty', methods=['POST'])
def handle_webhook():
    data = request.get_json()

    event = data.get('event')
    object_name = data.get('objectName')
    record_id = data.get('recordId')
    record_data = data.get('data')

    print(f"Received {event} for {object_name} record {record_id}")
    print(f"Data: {json.dumps(record_data, indent=2)}")

    # Process the webhook data here
    process_webhook_event(event, object_name, record_data)

    return jsonify({"status": "success"}), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=3000)
```

### Step 2: Configure Webhook in Twenty

#### Access Webhook Settings
1. Log in to your Twenty workspace
2. Navigate to **Settings** â†’ **APIs & Webhooks**
3. Click on the **Webhooks** tab
4. Click **+ Create Webhook**

#### Configure Webhook Details
1. **Webhook URL**: Enter your endpoint URL (e.g., `https://yourapp.com/webhooks/twenty`)
2. **Events**: Select which events you want to receive
3. **Objects**: Choose which objects to monitor (People, Companies, Opportunities, etc.)
4. **Name**: Give your webhook a descriptive name
5. **Description**: Add notes about what this webhook is for

<img src="/images/user-guide/webhooks/create-webhook.png" style={{width:'100%'}} alt="Create Webhook" />

#### Test Your Webhook
1. Click **Test Webhook** to send a sample payload
2. Verify that your endpoint receives the test data
3. Check your application logs to confirm processing works
4. Save the webhook configuration

### Step 3: Handle Webhook Security

**Verify webhook authenticity** using signature validation:

**Node.js example with signature verification**:
```javascript
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload, 'utf8')
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature, 'hex'),
    Buffer.from(expectedSignature, 'hex')
  );
}

app.post('/webhooks/twenty', (req, res) => {
  const signature = req.headers['x-twenty-signature'];
  const payload = JSON.stringify(req.body);

  if (!verifyWebhookSignature(payload, signature, process.env.WEBHOOK_SECRET)) {
    return res.status(401).send('Unauthorized');
  }

  // Process webhook...
  res.status(200).send('OK');
});
```

## Processing Webhook Events

### Event Handling Patterns

**Event Router Pattern**:
```javascript
function processWebhookEvent(event, objectName, data, previousData) {
  const eventKey = `${objectName}.${event.split('.')[1]}`;

  const handlers = {
    'person.created': handlePersonCreated,
    'person.updated': handlePersonUpdated,
    'company.created': handleCompanyCreated,
    'opportunity.updated': handleOpportunityUpdated,
    // Add more handlers as needed
  };

  const handler = handlers[eventKey];
  if (handler) {
    handler(data, previousData);
  } else {
    console.log(`No handler for event: ${eventKey}`);
  }
}

function handlePersonCreated(personData) {
  console.log(`New person created: ${personData.firstName} ${personData.lastName}`);
  // Sync to external CRM, send welcome email, etc.
}

function handleOpportunityUpdated(opportunityData, previousData) {
  if (opportunityData.stage === 'Closed Won' && previousData.stage !== 'Closed Won') {
    console.log(`Deal closed: ${opportunityData.name} for $${opportunityData.amount}`);
    // Trigger onboarding workflow, notify sales team, etc.
  }
}
```

### Data Synchronization

**Sync to external database**:
```javascript
async function syncPersonToExternalDB(personData) {
  try {
    const existingRecord = await externalDB.findByTwentyId(personData.id);

    if (existingRecord) {
      // Update existing record
      await externalDB.updatePerson(existingRecord.id, {
        firstName: personData.firstName,
        lastName: personData.lastName,
        email: personData.email,
        companyName: personData.company?.name,
        lastUpdated: new Date()
      });
    } else {
      // Create new record
      await externalDB.createPerson({
        twentyId: personData.id,
        firstName: personData.firstName,
        lastName: personData.lastName,
        email: personData.email,
        companyName: personData.company?.name,
        createdAt: new Date()
      });
    }
  } catch (error) {
    console.error('Failed to sync person to external DB:', error);
    // Implement retry logic or error handling
  }
}
```

### Notification Systems

**Send Slack notifications**:
```javascript
async function sendSlackNotification(event, objectName, data) {
  const webhookUrl = process.env.SLACK_WEBHOOK_URL;

  let message;
  if (event === 'opportunity.updated' && data.stage === 'Closed Won') {
    message = {
      text: `ðŸŽ‰ Deal Closed!`,
      attachments: [{
        color: 'good',
        fields: [
          { title: 'Deal Name', value: data.name, short: true },
          { title: 'Amount', value: `$${data.amount.toLocaleString()}`, short: true },
          { title: 'Account', value: data.company?.name || 'N/A', short: true }
        ]
      }]
    };
  }

  if (message) {
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message)
    });
  }
}
```

## Advanced Webhook Patterns

### Batch Processing

**Handle high-volume events efficiently**:
```javascript
class WebhookProcessor {
  constructor() {
    this.eventQueue = [];
    this.batchSize = 10;
    this.batchTimeout = 5000; // 5 seconds

    setInterval(() => this.processBatch(), this.batchTimeout);
  }

  addEvent(event) {
    this.eventQueue.push(event);

    if (this.eventQueue.length >= this.batchSize) {
      this.processBatch();
    }
  }

  async processBatch() {
    if (this.eventQueue.length === 0) return;

    const batch = this.eventQueue.splice(0, this.batchSize);

    try {
      await this.processEventBatch(batch);
    } catch (error) {
      console.error('Batch processing failed:', error);
      // Implement retry logic
    }
  }

  async processEventBatch(events) {
    // Process multiple events together for efficiency
    const updates = events.map(event => ({
      id: event.recordId,
      data: event.data,
      timestamp: event.timestamp
    }));

    await externalAPI.bulkUpdate(updates);
  }
}
```

### Retry Logic

**Handle failed webhook processing**:
```javascript
async function processWebhookWithRetry(event, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await processWebhookEvent(event);
      return; // Success, exit retry loop
    } catch (error) {
      console.error(`Webhook processing attempt ${attempt} failed:`, error);

      if (attempt === maxRetries) {
        // Final attempt failed, log to dead letter queue
        await logFailedWebhook(event, error);
        throw error;
      }

      // Wait before retrying (exponential backoff)
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Idempotency

**Handle duplicate webhook deliveries**:
```javascript
const processedEvents = new Set();

function isEventProcessed(eventId) {
  return processedEvents.has(eventId);
}

function markEventProcessed(eventId) {
  processedEvents.add(eventId);

  // Clean up old entries periodically
  if (processedEvents.size > 10000) {
    // Keep only recent events (implement LRU cache or similar)
  }
}

app.post('/webhooks/twenty', (req, res) => {
  const eventId = `${req.body.recordId}-${req.body.timestamp}`;

  if (isEventProcessed(eventId)) {
    console.log(`Duplicate event ignored: ${eventId}`);
    return res.status(200).send('OK');
  }

  processWebhookEvent(req.body);
  markEventProcessed(eventId);

  res.status(200).send('OK');
});
```

## Testing and Debugging

### Local Development

**Use ngrok for local testing**:
```bash
# Install ngrok
npm install -g ngrok

# Expose your local server
ngrok http 3000

# Use the ngrok URL in your webhook configuration
# Example: https://abc123.ngrok.io/webhooks/twenty
```

**Test webhook locally**:
```javascript
// Create a test webhook payload
const testPayload = {
  event: 'person.created',
  objectName: 'person',
  recordId: 'test-123',
  workspaceId: 'test-workspace',
  timestamp: new Date().toISOString(),
  data: {
    id: 'test-123',
    firstName: 'Test',
    lastName: 'User',
    email: 'test@example.com'
  }
};

// Send test webhook to your local endpoint
fetch('http://localhost:3000/webhooks/twenty', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(testPayload)
});
```

### Monitoring and Logging

**Comprehensive webhook logging**:
```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'webhooks.log' }),
    new winston.transports.Console()
  ]
});

app.post('/webhooks/twenty', (req, res) => {
  const startTime = Date.now();

  logger.info('Webhook received', {
    event: req.body.event,
    objectName: req.body.objectName,
    recordId: req.body.recordId,
    timestamp: req.body.timestamp
  });

  try {
    processWebhookEvent(req.body);

    logger.info('Webhook processed successfully', {
      recordId: req.body.recordId,
      processingTime: Date.now() - startTime
    });

    res.status(200).send('OK');
  } catch (error) {
    logger.error('Webhook processing failed', {
      recordId: req.body.recordId,
      error: error.message,
      stack: error.stack,
      processingTime: Date.now() - startTime
    });

    res.status(500).send('Internal Server Error');
  }
});
```

## Troubleshooting Common Issues

### Webhook Not Receiving Events

**Check these common issues**:
- **URL accessibility**: Ensure your webhook URL is publicly accessible
- **HTTPS requirement**: Many webhook providers require HTTPS endpoints
- **Firewall settings**: Check that your server can receive incoming connections
- **Event configuration**: Verify you've selected the correct events and objects

### Duplicate Events

**Causes and solutions**:
- **Network retries**: Implement idempotency to handle duplicate deliveries
- **Multiple webhooks**: Check that you haven't created duplicate webhook configurations
- **Processing failures**: Ensure your endpoint returns 200 OK for successful processing

### Performance Issues

**Optimization strategies**:
- **Async processing**: Handle webhook events asynchronously to respond quickly
- **Batch processing**: Group multiple events for efficient processing
- **Queue systems**: Use message queues for high-volume webhook processing
- **Caching**: Cache frequently accessed data to reduce processing time

## Security Best Practices

### Endpoint Security

**Secure your webhook endpoints**:
- **Use HTTPS**: Always use encrypted connections
- **Verify signatures**: Validate webhook authenticity using signatures
- **Rate limiting**: Implement rate limiting to prevent abuse
- **IP whitelisting**: Restrict access to known IP addresses if possible

### Data Handling

**Protect sensitive data**:
- **Validate input**: Always validate webhook payload structure
- **Sanitize data**: Clean data before processing or storing
- **Audit logging**: Log webhook events for security auditing
- **Access control**: Limit who can configure webhooks in your workspace

## Next Steps

After setting up webhooks:
- [Learn about handling webhook events](/user-guide/How-To Tutorials/developers/webhooks/how-to-handle-webhook-events)
- [Explore webhook security](/user-guide/How-To Tutorials/developers/webhooks/how-to-secure-webhook-endpoints)
- [Build custom integrations](/user-guide/How-To Tutorials/developers/integrations-apps/how-to-build-a-custom-integration)

Webhooks are a powerful tool for building real-time integrations with Twenty. Start with simple event handling and gradually build more sophisticated processing as your integration needs grow.
