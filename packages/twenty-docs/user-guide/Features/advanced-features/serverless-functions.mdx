---
title: Serverless Functions
info: "Deploy and manage serverless functions to extend Twenty's capabilities."
---

<Frame>
  <img src="/images/user-guide/serverless/serverless-functions.png" alt="Serverless Functions" />
</Frame>

Serverless functions in Twenty allow you to extend your CRM's capabilities by running custom code in response to events, API calls, or scheduled triggers. This powerful feature enables you to build sophisticated integrations and automations without managing server infrastructure.

## What Are Serverless Functions?

### Overview
Serverless functions are small pieces of code that run in Twenty's cloud environment. They execute automatically in response to specific triggers and can interact with your CRM data, external APIs, and other services.

### Key Benefits
- **No infrastructure management**: Focus on code, not servers
- **Automatic scaling**: Functions scale up and down based on demand
- **Event-driven execution**: Run code in response to CRM events
- **Secure environment**: Functions run in isolated, secure containers
- **Cost-effective**: Pay only for actual execution time

### Common Use Cases
- **Data transformation**: Clean, validate, or enrich data before saving
- **External integrations**: Connect with APIs and services not natively supported
- **Custom business logic**: Implement complex calculations or rules
- **Automated workflows**: Create sophisticated multi-step processes
- **Real-time notifications**: Send alerts to external systems

## Function Types and Triggers

### Event-Driven Functions

**Record Events**:
- Trigger when records are created, updated, or deleted
- Access both current and previous record data
- Modify data before it's saved to the database
- Validate data and prevent invalid operations

**Workflow Integration**:
- Execute as part of automated workflows
- Receive data from previous workflow steps
- Return data to subsequent workflow steps
- Handle complex conditional logic

### API Functions

**HTTP Endpoints**:
- Create custom API endpoints for your workspace
- Handle GET, POST, PUT, DELETE requests
- Accept parameters and request bodies
- Return custom responses and data formats

**Webhook Handlers**:
- Process incoming webhooks from external services
- Transform external data into Twenty format
- Trigger internal workflows based on external events
- Implement custom authentication and validation

### Scheduled Functions

**Time-Based Triggers**:
- Run functions on specific schedules (hourly, daily, weekly)
- Perform maintenance tasks and data cleanup
- Generate reports and send notifications
- Sync data with external systems

**Recurring Processes**:
- Implement complex business processes that span multiple days
- Handle subscription renewals and billing cycles
- Monitor data quality and send alerts
- Perform batch operations on large datasets

## Creating Serverless Functions

### Function Development Environment

**Code Editor**:
- Built-in code editor with syntax highlighting
- Support for JavaScript/TypeScript
- Autocomplete for Twenty APIs and objects
- Real-time error checking and validation

**Testing Tools**:
- Test functions with sample data
- Debug with console logs and breakpoints
- Monitor execution time and resource usage
- Simulate different trigger conditions

### Basic Function Structure

**Simple Event Handler**:
```javascript
export default async function handler(event, context) {
  // Access the triggering record
  const record = event.data;

  // Perform custom logic
  if (record.amount > 50000) {
    // Send notification for large deals
    await sendSlackNotification({
      message: `Large deal created: ${record.name} - $${record.amount}`,
      channel: '#sales-alerts'
    });
  }

  // Return modified data or status
  return {
    success: true,
    message: 'Deal processed successfully'
  };
}
```

**API Endpoint Function**:
```javascript
export default async function handler(request, context) {
  const { method, body, params } = request;

  if (method === 'POST') {
    // Create a new record based on external data
    const newContact = await context.twenty.create('person', {
      firstName: body.first_name,
      lastName: body.last_name,
      email: body.email,
      company: { connect: { id: body.company_id } }
    });

    return {
      status: 201,
      body: { id: newContact.id, message: 'Contact created' }
    };
  }

  return {
    status: 405,
    body: { error: 'Method not allowed' }
  };
}
```

### Advanced Function Patterns

**Data Validation Function**:
```javascript
export default async function validateDeal(event, context) {
  const deal = event.data;
  const errors = [];

  // Custom validation rules
  if (deal.amount > 100000 && !deal.approvalRequired) {
    errors.push('Deals over $100k require approval');
  }

  if (deal.closeDate < new Date()) {
    errors.push('Close date cannot be in the past');
  }

  // Check for existing deals with same company
  const existingDeals = await context.twenty.findMany('opportunity', {
    where: {
      company: { id: deal.company.id },
      stage: { in: ['Negotiation', 'Proposal'] }
    }
  });

  if (existingDeals.length > 0) {
    errors.push('Company already has active deals in pipeline');
  }

  if (errors.length > 0) {
    throw new Error(errors.join('; '));
  }

  return { valid: true };
}
```

**External API Integration**:
```javascript
export default async function enrichContact(event, context) {
  const person = event.data;

  if (!person.email) return;

  try {
    // Call external enrichment service
    const response = await fetch('https://api.clearbit.com/v2/people/find', {
      headers: {
        'Authorization': `Bearer ${process.env.CLEARBIT_API_KEY}`
      },
      params: { email: person.email }
    });

    const enrichmentData = await response.json();

    // Update the person record with enriched data
    await context.twenty.update('person', person.id, {
      jobTitle: enrichmentData.employment?.title,
      company: enrichmentData.employment?.name,
      linkedinUrl: enrichmentData.linkedin?.handle,
      location: enrichmentData.location
    });

    return { enriched: true, source: 'clearbit' };
  } catch (error) {
    console.error('Enrichment failed:', error);
    return { enriched: false, error: error.message };
  }
}
```

## Function Context and APIs

### Twenty API Access

**Database Operations**:
```javascript
// Create records
const newRecord = await context.twenty.create('objectName', data);

// Find records
const records = await context.twenty.findMany('objectName', {
  where: { field: 'value' },
  include: { relatedObject: true }
});

// Update records
await context.twenty.update('objectName', recordId, updateData);

// Delete records
await context.twenty.delete('objectName', recordId);
```

**Relationship Management**:
```javascript
// Connect related records
await context.twenty.update('opportunity', dealId, {
  company: { connect: { id: companyId } },
  contacts: { connect: [{ id: contactId1 }, { id: contactId2 }] }
});

// Disconnect relationships
await context.twenty.update('person', personId, {
  company: { disconnect: true }
});
```

### Environment and Configuration

**Environment Variables**:
```javascript
// Access secure configuration
const apiKey = process.env.EXTERNAL_API_KEY;
const webhookSecret = process.env.WEBHOOK_SECRET;
const databaseUrl = process.env.DATABASE_URL;
```

**Function Metadata**:
```javascript
// Access function execution context
console.log('Function name:', context.functionName);
console.log('Execution ID:', context.executionId);
console.log('User ID:', context.userId);
console.log('Workspace ID:', context.workspaceId);
```

### External Service Integration

**HTTP Requests**:
```javascript
// Make external API calls
const response = await fetch('https://api.external-service.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${apiKey}`
  },
  body: JSON.stringify(payload)
});

const result = await response.json();
```

**Database Connections**:
```javascript
// Connect to external databases
const { Pool } = require('pg');
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

const result = await pool.query('SELECT * FROM external_table WHERE id = $1', [recordId]);
```

## Deployment and Management

### Function Deployment

**Deployment Process**:
1. **Write Function Code**: Develop and test your function locally
2. **Configure Triggers**: Set up event triggers and schedules
3. **Set Environment Variables**: Configure secure settings and API keys
4. **Deploy Function**: Push code to Twenty's serverless environment
5. **Monitor Execution**: Watch logs and performance metrics

**Version Control**:
- Functions support versioning and rollback
- Deploy new versions without downtime
- A/B test different function implementations
- Maintain multiple environments (dev, staging, production)

### Configuration Management

**Environment Variables**:
```javascript
// Secure configuration management
const config = {
  apiKey: process.env.EXTERNAL_API_KEY,
  webhookSecret: process.env.WEBHOOK_SECRET,
  databaseUrl: process.env.DATABASE_URL,
  slackToken: process.env.SLACK_BOT_TOKEN
};
```

**Function Settings**:
- **Timeout**: Maximum execution time (default: 30 seconds)
- **Memory**: Allocated memory for function execution
- **Concurrency**: Maximum parallel executions
- **Retry Policy**: How to handle failed executions

### Monitoring and Debugging

**Execution Logs**:
```javascript
// Comprehensive logging
console.log('Function started:', { recordId: event.data.id });
console.error('Error occurred:', error.message);
console.warn('Validation warning:', validationResult);

// Structured logging
context.logger.info('Processing record', {
  recordId: event.data.id,
  recordType: event.objectName,
  timestamp: new Date().toISOString()
});
```

**Performance Monitoring**:
- Track execution time and resource usage
- Monitor error rates and success metrics
- Set up alerts for function failures
- Analyze performance trends over time

## Security and Best Practices

### Security Considerations

**Data Access Control**:
- Functions inherit user permissions for data access
- Implement additional validation for sensitive operations
- Use secure environment variables for API keys
- Validate all input data to prevent injection attacks

**External Communication**:
- Use HTTPS for all external API calls
- Validate webhook signatures for incoming requests
- Implement rate limiting for external service calls
- Handle authentication tokens securely

### Performance Optimization

**Efficient Code Patterns**:
```javascript
// Batch operations for better performance
const updates = records.map(record => ({
  id: record.id,
  data: processRecord(record)
}));

await context.twenty.updateMany('objectName', updates);

// Cache frequently accessed data
const cache = new Map();
function getCachedData(key) {
  if (!cache.has(key)) {
    cache.set(key, expensiveOperation(key));
  }
  return cache.get(key);
}
```

**Resource Management**:
- Minimize memory usage for large datasets
- Use streaming for processing large files
- Implement connection pooling for database access
- Clean up resources properly to avoid memory leaks

### Error Handling

**Robust Error Handling**:
```javascript
export default async function handler(event, context) {
  try {
    // Main function logic
    const result = await processEvent(event);
    return { success: true, result };
  } catch (error) {
    // Log error details
    context.logger.error('Function execution failed', {
      error: error.message,
      stack: error.stack,
      eventData: event.data
    });

    // Return appropriate error response
    if (error.name === 'ValidationError') {
      return { success: false, error: 'Invalid data provided' };
    }

    // Re-throw for system-level errors
    throw error;
  }
}
```

## Advanced Use Cases

### Complex Business Logic

**Multi-Step Approval Process**:
```javascript
export default async function approvalWorkflow(event, context) {
  const deal = event.data;

  // Determine approval requirements
  const approvalRules = await getApprovalRules(deal.amount, deal.type);

  // Create approval tasks
  for (const rule of approvalRules) {
    await context.twenty.create('task', {
      title: `Approve ${deal.name}`,
      description: `Deal requires ${rule.level} approval`,
      assignee: { connect: { id: rule.approverId } },
      relatedTo: { connect: { id: deal.id } },
      dueDate: new Date(Date.now() + rule.timeoutHours * 60 * 60 * 1000)
    });
  }

  // Update deal status
  await context.twenty.update('opportunity', deal.id, {
    stage: 'Pending Approval',
    approvalStatus: 'In Progress'
  });
}
```

**Data Synchronization**:
```javascript
export default async function syncToExternalSystem(event, context) {
  const record = event.data;

  // Transform data for external system
  const externalData = transformToExternalFormat(record);

  // Check if record exists in external system
  const existingRecord = await findExternalRecord(record.id);

  if (existingRecord) {
    // Update existing record
    await updateExternalRecord(existingRecord.id, externalData);
  } else {
    // Create new record
    const newExternalRecord = await createExternalRecord(externalData);

    // Store external ID for future reference
    await context.twenty.update(event.objectName, record.id, {
      externalId: newExternalRecord.id,
      lastSyncDate: new Date()
    });
  }
}
```

### Integration Patterns

**Webhook Processing**:
```javascript
export default async function processWebhook(request, context) {
  // Verify webhook signature
  const signature = request.headers['x-webhook-signature'];
  if (!verifySignature(request.body, signature, process.env.WEBHOOK_SECRET)) {
    return { status: 401, body: { error: 'Invalid signature' } };
  }

  const payload = JSON.parse(request.body);

  // Process different event types
  switch (payload.event_type) {
    case 'payment.completed':
      await handlePaymentCompleted(payload.data);
      break;
    case 'subscription.cancelled':
      await handleSubscriptionCancelled(payload.data);
      break;
    default:
      console.log('Unhandled event type:', payload.event_type);
  }

  return { status: 200, body: { received: true } };
}
```

## Troubleshooting and Support

### Common Issues

**Function Timeouts**:
- Optimize code for better performance
- Increase timeout settings if necessary
- Break large operations into smaller chunks
- Use asynchronous processing for long-running tasks

**Memory Limits**:
- Monitor memory usage during execution
- Optimize data structures and algorithms
- Process large datasets in batches
- Increase memory allocation if needed

**API Rate Limits**:
- Implement exponential backoff for retries
- Use connection pooling for database access
- Cache frequently accessed data
- Batch API calls when possible

### Debugging Strategies

**Local Testing**:
```javascript
// Create test harness for local development
const testEvent = {
  data: { /* test record data */ },
  objectName: 'opportunity',
  eventType: 'created'
};

const testContext = {
  twenty: mockTwentyAPI,
  logger: console,
  functionName: 'test-function'
};

// Run function locally
const result = await handler(testEvent, testContext);
console.log('Result:', result);
```

**Production Monitoring**:
- Use structured logging for better debugging
- Set up alerts for function failures
- Monitor execution metrics and trends
- Implement health checks for critical functions

## Next Steps

After understanding serverless functions:
- [Explore custom page layouts](/user-guide/Features/advanced-features/custom-page-layouts)
- [Learn about advanced permissions](/user-guide/Features/advanced-features/advanced-permissions)
- [Discover data governance features](/user-guide/Features/advanced-features/data-governance)

Serverless functions unlock unlimited possibilities for extending Twenty's capabilities. Start with simple use cases and gradually build more sophisticated integrations as your needs grow.
